{
 "Description": "EFS Restore",
 "Outputs": {
  "LambdaFunctionArn": {
   "Description": "Full ARN of the Lambda function",
   "Value": {
    "Fn::GetAtt": [
     "EfsRestoreLambdaFunction",
     "Arn"
    ]
   }
  },
  "LambdaFunctionName": {
   "Description": "Lambda function name for use with aws lambda invoke",
   "Value": {
    "Ref": "EfsRestoreLambdaFunction"
   }
  }
 },
 "Parameters": {
  "FileSystemId": {
   "Description": "EFS filesystem ID to mount",
   "Type": "String"
  },
  "RestoreDirectoryPattern": {
   "Default": "aws-backup-restore_*",
   "Description": "Directory name pattern for restore directories",
   "Type": "String"
  },
  "SecurityGroupId": {
   "Description": "Security group already configured for NFS access (port 2049)",
   "Type": "String"
  },
  "SubnetId": {
   "Description": "Subnet for Lambda deployment",
   "Type": "String"
  }
 },
 "Resources": {
  "EfsRestoreAccessPoint": {
   "Properties": {
    "FileSystemId": {
     "Ref": "FileSystemId"
    },
    "PosixUser": {
     "Gid": "0",
     "Uid": "0"
    },
    "RootDirectory": {
     "Path": "/"
    }
   },
   "Type": "AWS::EFS::AccessPoint"
  },
  "EfsRestoreLambdaFunction": {
   "Properties": {
    "Architectures": [
     "arm64"
    ],
    "Code": {
     "ZipFile": "import glob\nimport logging\nimport os\nimport shutil\nimport time\nfrom pathlib import Path\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\n\ndef log_progress(message, extra=None):\n    \"\"\"Log progress with optional extra data\"\"\"\n    if extra:\n        logger.info(message, extra={'extra': extra})\n    else:\n        logger.info(message)\n\n\ndef find_restore_directories(pattern):\n    \"\"\"Find directories matching the restore pattern\"\"\"\n    try:\n        efs_root = Path('/mnt/efs')\n        if not efs_root.exists():\n            raise Exception(\"EFS root directory /mnt/efs does not exist\")\n\n        # Convert glob pattern to search pattern\n        search_pattern = str(efs_root / pattern)\n        matching_dirs = glob.glob(search_pattern)\n\n        # Filter to only include directories\n        restore_dirs = [d for d in matching_dirs if os.path.isdir(d)]\n\n        log_progress(\n            f\"Found {len(restore_dirs)} directories matching pattern \"\n            f\"'{pattern}'\",\n            {'pattern': pattern, 'directories': restore_dirs}\n        )\n\n        return restore_dirs\n\n    except Exception as e:\n        log_progress(f\"Error finding restore directories: {str(e)}\",\n                     {'error': str(e)})\n        raise\n\n\ndef check_for_conflicts(source_dir, target_root):\n    \"\"\"Check if moving files would create conflicts\"\"\"\n    conflicts = []\n    source_path = Path(source_dir)\n    target_path = Path(target_root)\n\n    try:\n        for item in source_path.rglob('*'):\n            if item.is_file() or item.is_dir():\n                relative_path = item.relative_to(source_path)\n                target_item = target_path / relative_path\n\n                if target_item.exists():\n                    conflicts.append(str(relative_path))\n\n        if conflicts:\n            log_progress(f\"Found {len(conflicts)} conflicts\",\n                         {'conflicts': conflicts})\n\n        return conflicts\n\n    except Exception as e:\n        log_progress(f\"Error checking for conflicts: {str(e)}\",\n                     {'error': str(e)})\n        raise\n\n\ndef move_contents(source_dir, target_root):\n    \"\"\"Move all contents from source directory to target root\"\"\"\n    try:\n        source_path = Path(source_dir)\n        target_path = Path(target_root)\n\n        moved_items = []\n        failed_items = []\n\n        # Get all items in source directory\n        items = list(source_path.iterdir())\n        total_items = len(items)\n\n        log_progress(\n            f\"Starting to move {total_items} items from {source_dir} \"\n            f\"to {target_root}\"\n        )\n\n        for i, item in enumerate(items, 1):\n            try:\n                target_item = target_path / item.name\n\n                # Use shutil.move for atomic move operation\n                shutil.move(str(item), str(target_item))\n                moved_items.append(item.name)\n\n                # Log progress every 10 items\n                if i % 10 == 0 or i == total_items:\n                    log_progress(\n                        f\"Progress: {i}/{total_items} items moved\",\n                        {\n                            'moved': len(moved_items),\n                            'failed': len(failed_items)\n                        }\n                    )\n\n            except Exception as e:\n                failed_items.append({'item': item.name, 'error': str(e)})\n                log_progress(\n                    f\"Failed to move {item.name}: {str(e)}\",\n                    {'item': item.name, 'error': str(e)}\n                )\n\n        log_progress(\n            \"Move operation completed\",\n            {\n                'total_items': total_items,\n                'moved': len(moved_items),\n                'failed': len(failed_items)\n            }\n        )\n\n        if failed_items:\n            raise Exception(\n                f\"Failed to move {len(failed_items)} items: {failed_items}\"\n            )\n\n        return moved_items\n\n    except Exception as e:\n        log_progress(f\"Error moving contents: {str(e)}\", {'error': str(e)})\n        raise\n\n\ndef cleanup_empty_directory(directory):\n    \"\"\"Remove the empty restore directory\"\"\"\n    try:\n        source_path = Path(directory)\n\n        # Verify directory is empty\n        if any(source_path.iterdir()):\n            raise Exception(\n                f\"Directory {directory} is not empty, cannot remove\"\n            )\n\n        source_path.rmdir()\n        log_progress(f\"Successfully removed empty directory: {directory}\")\n\n    except Exception as e:\n        log_progress(\n            f\"Error removing directory {directory}: {str(e)}\",\n            {'error': str(e)}\n        )\n        raise\n\n\ndef handle(event, context):\n    start_time = time.time()\n\n    try:\n        log_progress(\n            \"Starting EFS restore directory move operation\",\n            {\n                'event': event,\n                'context': {\n                    'function_name': context.function_name,\n                    'function_version': context.function_version,\n                    'invoked_function_arn': context.invoked_function_arn,\n                    'memory_limit_in_mb': context.memory_limit_in_mb,\n                    'remaining_time_in_millis': (\n                        context.get_remaining_time_in_millis()\n                    )\n                }\n            }\n        )\n\n        # Get restore directory pattern from environment\n        restore_pattern = os.environ.get(\n            'RESTORE_DIRECTORY_PATTERN', 'aws-backup-restore_*'\n        )\n        log_progress(f\"Using restore directory pattern: {restore_pattern}\")\n\n        # Find restore directories\n        restore_dirs = find_restore_directories(restore_pattern)\n\n        if not restore_dirs:\n            error_msg = (\n                f\"No directories found matching pattern '{restore_pattern}' \"\n                f\"in /mnt/efs\"\n            )\n            log_progress(error_msg)\n            raise Exception(error_msg)\n\n        if len(restore_dirs) > 1:\n            error_msg = (\n                f\"Multiple restore directories found: {restore_dirs}. \"\n                f\"Only one restore directory is allowed.\"\n            )\n            log_progress(error_msg)\n            raise Exception(error_msg)\n\n        restore_dir = restore_dirs[0]\n        log_progress(f\"Processing restore directory: {restore_dir}\")\n\n        # Check for conflicts\n        conflicts = check_for_conflicts(restore_dir, '/mnt/efs')\n        if conflicts:\n            error_msg = (\n                f\"Conflicts detected. The following files/directories \"\n                f\"already exist in /mnt/efs: {conflicts}\"\n            )\n            log_progress(error_msg)\n            raise Exception(error_msg)\n\n        # Move contents\n        moved_items = move_contents(restore_dir, '/mnt/efs')\n\n        # Clean up empty directory\n        cleanup_empty_directory(restore_dir)\n\n        execution_time = time.time() - start_time\n\n        result = {\n            'statusCode': 200,\n            'body': {\n                'message': (\n                    'Successfully moved restore directory contents to EFS root'\n                ),\n                'restore_directory': restore_dir,\n                'moved_items_count': len(moved_items),\n                'execution_time_seconds': round(execution_time, 2),\n                'moved_items': moved_items\n            }\n        }\n\n        log_progress(\n            \"EFS restore directory move operation completed successfully\",\n            {'result': result['body']}\n        )\n\n        return result\n\n    except Exception as e:\n        execution_time = time.time() - start_time\n        error_msg = f\"EFS restore directory move operation failed: {str(e)}\"\n\n        log_progress(\n            error_msg,\n            {\n                'error': str(e),\n                'execution_time_seconds': round(execution_time, 2)\n            }\n        )\n\n        return {\n            'statusCode': 500,\n            'body': {\n                'message': error_msg,\n                'error': str(e),\n                'execution_time_seconds': round(execution_time, 2)\n            }\n        }"
    },
    "Environment": {
     "Variables": {
      "RESTORE_DIRECTORY_PATTERN": {
       "Ref": "RestoreDirectoryPattern"
      }
     }
    },
    "FileSystemConfigs": [
     {
      "Arn": {
       "Fn::GetAtt": [
        "EfsRestoreAccessPoint",
        "Arn"
       ]
      },
      "LocalMountPath": "/mnt/efs"
     }
    ],
    "Handler": "index.handle",
    "LoggingConfig": {
     "ApplicationLogLevel": "INFO",
     "LogFormat": "JSON",
     "LogGroup": {
      "Ref": "EfsRestoreLogGroup"
     },
     "SystemLogLevel": "INFO"
    },
    "MemorySize": 1024,
    "ReservedConcurrentExecutions": 1,
    "Role": {
     "Fn::GetAtt": [
      "EfsRestoreRole",
      "Arn"
     ]
    },
    "Runtime": "python3.13",
    "Timeout": 900,
    "VpcConfig": {
     "SecurityGroupIds": [
      {
       "Ref": "SecurityGroupId"
      }
     ],
     "SubnetIds": [
      {
       "Ref": "SubnetId"
      }
     ]
    }
   },
   "Type": "AWS::Lambda::Function"
  },
  "EfsRestoreLogGroup": {
   "DeletionPolicy": "Delete",
   "Metadata": {
    "cfn_nag": {
     "rules_to_suppress": [
      {
       "id": "W84",
       "reason": "No sensitive data logged"
      }
     ]
    }
   },
   "Properties": {
    "LogGroupName": {
     "Fn::Sub": "/aws/lambda/${AWS::StackName}-efs-restore"
    },
    "RetentionInDays": "3"
   },
   "Type": "AWS::Logs::LogGroup",
   "UpdateReplacePolicy": "Delete"
  },
  "EfsRestoreRole": {
   "Properties": {
    "AssumeRolePolicyDocument": {
     "Statement": [
      {
       "Action": "sts:AssumeRole",
       "Effect": "Allow",
       "Principal": {
        "Service": "lambda.amazonaws.com"
       }
      }
     ],
     "Version": "2012-10-17"
    },
    "ManagedPolicyArns": [
     "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
    ],
    "Policies": [
     {
      "PolicyDocument": {
       "Statement": [
        {
         "Action": [
          "ec2:CreateNetworkInterface",
          "ec2:DeleteNetworkInterface",
          "ec2:DescribeNetworkInterfaces",
          "ec2:DetachNetworkInterface"
         ],
         "Effect": "Allow",
         "Resource": "*"
        }
       ],
       "Version": "2012-10-17"
      },
      "PolicyName": "VpcAccessPolicy"
     }
    ]
   },
   "Type": "AWS::IAM::Role"
  }
 }
}
